---title: "Stripe Tips for Indie Devs: Webhooks, Idempotency, and Test Clocks"
date: "2025-02-20"
tags: ["Stripe", "Payments", "Web Development"]
summary: "Lessons learned integrating Stripe into Hixbi, including webhook handling, testing strategies, and common pitfalls."
---

# Stripe Tips for Indie Devs

Integrating Stripe into Hixbi taught me valuable lessons about payment systems. Here are the most important things I wish I knew before starting.

## 1. Webhook Handling is Critical

Stripe webhooks are how you learn about subscription changes, payment failures, and other events. Handle them correctly or face angry customers.

**Key principles:**
- Verify webhook signatures ALWAYS
- Return 200 immediately, process async
- Handle duplicate events (they happen)
- Log everything for debugging

```typescript
export async function POST(request: Request) {
  const signature = request.headers.get('stripe-signature')
  const body = await request.text()
  
  let event
  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET
    )
  } catch (err) {
    return new Response('Invalid signature', { status: 400 })
  }
  
  // Queue for async processing
  await queue.add('stripe-event', { eventId: event.id })
  
  return new Response('OK', { status: 200 })
}
```

## 2. Idempotency Keys Save Lives

Network issues cause duplicate payment attempts. Idempotency keys ensure charges happen only once.

```typescript
await stripe.paymentIntents.create({
  amount: 2000,
  currency: 'usd',
  customer: customerId
}, {
  idempotencyKey: `user_${userId}_${Date.now()}`
})
```

## 3. Test Clocks for Subscription Testing

Testing subscription billing cycles manually is painful. Stripe's test clocks let you fast-forward time.

```typescript
// Create a test clock
const testClock = await stripe.testHelpers.testClocks.create({
  frozen_time: 1678886400, // March 15, 2023
})

// Create customer on test clock
const customer = await stripe.customers.create({
  email: 'test@example.com',
  test_clock: testClock.id
})

// Advance time 30 days
await stripe.testHelpers.testClocks.advance(testClock.id, {
  frozen_time: testClock.frozen_time + (30 * 24 * 60 * 60)
})
```

## 4. Handle Failed Payments Gracefully

Payments fail. Cards expire, banks decline, users forget to update payment info.

**My approach:**
1. Catch webhook: `invoice.payment_failed`
2. Send email notification with update link
3. Grace period: 7 days before downgrade
4. Retry with Smart Retries (Stripe does this automatically)

## 5. Separate Test and Production Data

Sounds obvious, but mixing test and production data is a common mistake. Use separate Stripe accounts or spaces, different database schemas, and clear naming conventions.

## Common Pitfalls

1. **Not handling SCA (3D Secure)**: European cards require additional authentication
2. **Hardcoding price IDs**: Use lookup keys instead
3. **Ignoring declined webhooks**: Always handle `charge.failed`
4. **Testing only with card numbers**: Use Stripe CLI for realistic scenarios

## What I'd Do Next

Next time, I'd set up a proper staging environment with Stripe test mode from day one, not after launch. Testing subscription edge cases in production is stressful and risky.

---
